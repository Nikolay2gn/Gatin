Gatin Nikolay 912 gr 
16 Polymorphism
Задание 1

Представьте себе стопку книг. Вы кладете первую, на нее вторую и т.д. А теперь хотите убрать книги. Если вы уберете нижнюю - то вся стопка развалится. Поэтому нужно убирать сверху. В этом и заключается тип данных Stack - куча или стопка.

Такой способ организации данных получил название LIFO (англ. last in, first out «последним пришёл — первым ушёл»).

Задание: Создайте класс Batary, у которой будет определен атрибут capacity = [ ] (емкость), max_charge = 5 (максимальный заряд) по умолчанию, и методы:

    charge - заряжает батарею

    discharge - разряжает батарею.

    Переопределите метод __str__, чтобы при вызове экземпляра он представлялся в виде: [)))))] - максимально заряженная батарея.

Подсказка: можете использовать методы очень похожего стандартного типа данных. Догадались какого?

class Batary:
  def __init__(self,capacity=[],max_charge=5):
    self.capacity = capacity
    self.max_charge = max_charge
  def charge(self):
    if len(self.capacity) < self.max_charge:
            self.capacity.append(')')
  def discharge(self):
    self.capacity.pop()
  def __str__(self):
    return f'Заряд батареи в данный момент:''[' + ''.join(self.capacity) + ']'

ex1 = Batary()
print(ex1)
ex1.charge()
ex1.discharge()
ex1.charge()
ex1.charge()
ex1.charge()
ex1.charge()
ex1.charge()
ex1.charge()
ex1.charge()
ex1.charge()
ex1.charge()
ex1.charge()
print(ex1)

Задание 2
Представьте себе очередь на кассе. К кассе подходит первый человек в очереди, а в конец очереди встает вновь пришедший. В программировании есть подобный тип данных - Queue (англ. "очередь"), основанный на принципе FIFO (англ. first in, first out «первым пришёл — первым ушёл»).
Задание:
        Реализовать класс Queue

        Определить атрибут inside, который будет хранить в себе имена людей в очереди.

        Переопределить метод __str__, чтобы преобразовать его к виду: Name1=>Name2=>...=>Name3

        Реализовать методы:
            add - который добавляет имя в очередь
            take_out убирает первого человека из списка

        Переопределить методы __add__ , __sub__, __iadd__, __isub__ чтобы они соответствовали методам add и take_out

class Queue:
    def __init__(self):
        self.inside = []

    def add(self, name):
        self.inside.append(name)

    def take_out(self):
        if len(self.inside) > 0:
            self.inside.pop(0)

    def __str__(self):
        return '=>'.join(self.inside)

    def __add__(self, name):
        self.add(name)
        return self

    def __sub__(self, name):
        self.take_out()
        return self

    def __iadd__(self, name):
        self.add(name)
        return self

    def __isub__(self, name):
        self.take_out()
        return self
queue = Queue()
queue.add('Dima')
queue.add('Max')
queue.add('Edik')
print(queue)  
queue.take_out()
print(queue) 
queue += 'Tim'
print(queue)  
queue -= 'Max'
print(queue)  

Задание 3
a) Создайте класс Matrix

который должен принимать данные (список списков) для формирования матрицы.

Пример ввода:
m1 = Matrix([[1,2,3], [4,5,6]])

это мы ввели матрицу: 

1 2 3
4 5 6

Подсказка

Матрица - система некоторых математческих величин, расположенных в виде прямоугольной схемы.

примеры матриц:

0  0        7  8  9
0  0        10 3 -1
            12 3  4

b) Следующий шаг

реализовать перегрузку метода __str__() для вывода матрицы в привычном виде.
c) Далеее

реализовать перегрузку метода __add__() для сложения двух объектов класса Matrix (двух матриц). Результатом сложения должна быть новая матрица.

Пример:

m1 = Matrix([[1,2,3],[4,5,6]])
m2 = Matrix([[6,5,4],[3,2,1]])

m3 = m1 + m2

print(m3)

7 7 7
7 7 7

class Matrix:
    def __init__(self, data):
        self.data = data
    
    def __str__(self):
        return "\n".join([" ".join(map(str, row)) for row in self.data])
    
    def __add__(self, other):
        if len(self.data) != len(other.data) or len(self.data[0]) != len(other.data[0]):
            return "Матрицы разные"
        result = []
        for i in range(len(self.data)):
            row = []
            for j in range(len(self.data[0])):
                row.append(self.data[i][j] + other.data[i][j])
            result.append(row)
        return Matrix(result)

m1 = Matrix([[4, 6],[1, 2]])


m2 = Matrix([[4, 3],[3, 2]])


print("Первая")
print(m1)


print("Вторая")
print(m2)


m3 = m1 + m2


print("Матрица получившаяся в результате сложения двух других")
print(m3)

